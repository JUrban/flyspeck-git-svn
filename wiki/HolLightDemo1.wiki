#John Harrison on using HOL Light

=Video Presentation=

John Harrison gives a [http://www.math.kobe-u.ac.jp/icms2006/icms2006-video/video/v103.html video demonstration] of how to use HOL Light.  The presentation lasts about 30 minutes, followed by questions and answers.

The theorem that he proves is a problem on an old international math olympiad (IMO).

=IMO problem and solution=

The IMO problem and solution discussed by Harrison is the following.

{{{

Problem [B2 from IMO 1972]
f and g are real-valued functions defined on the real line. For all x and y,

f(x + y) + f(x - y) = 2 f(x) g(y).
f is not identically zero and |f(x)| ≤ 1 for all x. Prove that |g(x)| ≤ 1 for all x.

Solution
Let k be the least upper bound for |f(x)|. Suppose |g(y)| > 1. Then

2k ≥ |f(x + y)| + |f(x - y)| ≥ |f(x + y) + f(x - y)| = 2 |g(y)||f(x)|,
so |f(x)| ≤ k/|g(y)|. In other words, k/|g(y)| is an upper bound for |f(x)| which is less than k. Contradiction.

}}}

Here is the [http://www.cs.ru.nl/~freek/demos/exercise/exercise.pdf pdf] solution, and a second [http://www.cs.ru.nl/~freek/demos/exercise/exercise2.pdf pdf] solution.


=HOL Light solution=

The video demo shows the steps he used to create the following proof, written by Harrison.
The first part is what he did during the video demo. The second version is another proof
of the same theorem he did later.  It is not part of the demo.  After the code, I give a line-by-line
commentary on the code.

As the video and the commentary show, it is hard to read the code just by looking at it.
To understand it, you "replay" it on the computer step by step.

{{{

(* ------------------------------------------------------------------------- *)
(* Cleaned-up proof from session.                                            *)
(* ------------------------------------------------------------------------- *)

needs "Multivariate/misc.ml";;

let IMO = prove
 (`!f g. (!x y. f(x + y) + f(x - y) = &2 * f(x) * g(y)) /\
        ~(!x. f(x) = &0) /\
        (!x. abs(f(x)) <= &1)
        ==> !x. abs(g(x)) <= &1`,
 let LL = REAL_ARITH `&1 < k ==> &0 < k` in
 REPEAT STRIP_TAC THEN SPEC_TAC(`x:real`,`y:real`) THEN
 ABBREV_TAC `k = sup (IMAGE (\x. abs(f(x))) (:real))` THEN
 MP_TAC(SPEC `IMAGE (\x. abs(f(x))) (:real)` SUP) THEN
 ASM_SIMP_TAC[FORALL_IN_IMAGE; EXISTS_IN_IMAGE; IN_UNIV] THEN
 ANTS_TAC THENL [ASM SET_TAC[]; STRIP_TAC] THEN
 SIMP_TAC[GSYM REAL_NOT_LT; GSYM NOT_EXISTS_THM] THEN STRIP_TAC THEN
 FIRST_X_ASSUM(MP_TAC o SPEC `k / abs(g(y:real))`) THEN
 SIMP_TAC[NOT_IMP; NOT_FORALL_THM] THEN CONJ_TAC THENL
  [ASM_MESON_TAC[REAL_LE_RDIV_EQ; REAL_ABS_MUL; LL;
     REAL_ARITH `u + v = &2 * z /\ abs u <= k /\ abs v <= k ==> abs z <= k`];
   ASM_MESON_TAC[REAL_NOT_LE; REAL_LT_LDIV_EQ; REAL_LT_LMUL; REAL_MUL_RID; LL;
     REAL_ARITH `~(z = &0) /\ abs z <= k ==> &0 < k`]]);;

(* ------------------------------------------------------------------------- *)
(* second proof.                                                            *)
(* ------------------------------------------------------------------------- *)

let LEMMA1 = prove
 (`(!x y. f(x + y) + f(x - y) = &2 * f(x) * g(y)) /\ (!x. abs(f x) <= &1)
  ==> !l x. abs(f x * (g y) pow l) <= &1`,
 DISCH_THEN(STRIP_ASSUME_TAC o GSYM) THEN INDUCT_TAC THEN
 ASM_SIMP_TAC[real_pow; REAL_MUL_RID] THEN GEN_TAC THEN MATCH_MP_TAC
  (REAL_ARITH `abs((&2 * a * b) * c) <= &2 ==> abs(a * b * c) <= &1`) THEN
 ASM_SIMP_TAC[] THEN FIRST_ASSUM(MP_TAC o SPEC `x + y`) THEN
 FIRST_ASSUM(MP_TAC o SPEC `x - y`) THEN REAL_ARITH_TAC);;

let LEMMA2 = prove
 (`~(x = &0) /\ &1 < abs(y) ==> ?n. &1 < abs(y pow n * x)`,
 SIMP_TAC[REAL_ABS_MUL; REAL_ABS_POW; GSYM REAL_LT_LDIV_EQ;
          GSYM REAL_ABS_NZ; REAL_ARCH_POW]);;

let IMO = prove
 (`!f g. (!x y. f(x + y) + f(x - y) = &2 * f(x) * g(y)) /\
        ~(!x. f(x) = &0) /\
        (!x. abs(f(x)) <= &1)
        ==> !x. abs(g(x)) <= &1`,
 MESON_TAC[LEMMA1; LEMMA2; REAL_NOT_LE; REAL_MUL_SYM]);;


}}}

=Commentary=

To get started, install [http://caml.inria.fr/ CAML] and [http://www.cl.cam.ac.uk/~jrh13/hol-light/ HOL Light] on your machine, following the instructions on page 5 of the [http://www.cl.cam.ac.uk/~jrh13/hol-light/tutorial_220.pdf tutorial].  It runs on most computers.

Start a session of CAML.  Load HOL Light.

==Step 0. Understand the conventional Proof==

Every formal proof starts with a conventional proof (that is, non-formal proof).  We should study the conventional math proof of the IMO problem (given above) and understand it thoroughly.  With a thorough understanding of the conventional proof, we are ready to move on.

==Step 1. Load theorems==

[http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/needs.html needs] ----  [http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/prioritize_real.html prioritize_real]

The first step of  the proof is
{{{
needs "Multivariate/misc.ml";;
}}}
In his proof of the IMO problem, Harrison uses some theorems that have already been proved in the file {{{"Multivariate/misc.ml"}}}.  This line tells the theorem prover to load those theorems.

Harrison doesn't include the following step, but I add it, to tell the theorem prover that I am working with the real numbers in this problem, rather than the natural numbers.  Otherwise, HOL Light might think x and y are natural numbers.
{{{
prioritize_real();;
}}}

==Step 2. State the theorem to be proved.==

[http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/prove.html prove] ----  [http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/g.html g]

The statement of the problem
{{{
f and g are real-valued functions defined on the real line. For all x and y,

f(x + y) + f(x - y) = 2 f(x) g(y).
f is not identically zero and |f(x)| ≤ 1 for all x. Prove that |g(x)| ≤ 1 for all x.
}}}
appears in HOL Light as follows:
{{{
let IMO = prove
 (`!f g. (!x y. f(x + y) + f(x - y) = &2 * f(x) * g(y)) /\
        ~(!x. f(x) = &0) /\
        (!x. abs(f(x)) <= &1)
        ==> !x. abs(g(x)) <= &1`,  (* TACTIC HERE *)  );;
}}}
The notation is explained in the HOL Light tutorial.  Real numbers need to be marked with {{{&}}}.  For instance,
{{{&0}}} is the real number zero (as opposed to the natural number zero {{{0}}}).  The logical symbol "and" is
typed as {{{/\}}}, "less than or equal" appears as {{{<=}}}, "the absolute value" as {{{abs}}}.  It is necessary to learn the names of different functions from the tutorial.

The function {{{prove}}} takes two arguments, a backquoted string giving the result that is to be proved, and a tactic that gives the proof.  The {{{prove}}} function is used after the proof is complete to package the proof into something that can be used by other people.  When the proof is being worked out, the desired theorem is stated as a goal.  For this, type {{{g}}} for goal and then the backquoted string.

{{{
g `!f g. (!x y. f(x + y) + f(x - y) = &2 * f(x) * g(y)) /\
        ~(!x. f(x) = &0) /\
        (!x. abs(f(x)) <= &1)
        ==> !x. abs(g(x)) <= &1`;;
}}}

==Step 3.  Work out proof tactics==

[http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/THEN.html THEN]  ----  [http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/THENL.html THENL]

The style of proving in HOL Light is generally "backwards".  This means that you start out with a goal of what you want to prove (in this case the IMO problem), and work backwards until you have reduced the goal to easier statements that are easy to prove.  Each backwards step of the proof is called a tactic.  If you look at the HOL Light proof of the IMO problem,  it has the general form
{{{
let IMO = prove
 (   (* backquoted goal *) ,  (* tactic *)  );;
}}}
The tactic, if you look carefully, is a long sequence of separate commands joined together with {{{THEN}}}.
The {{{THEN}}} function makes a single tactic out of many tactics.  For example, if we have three backwards proof steps called {{{tactic1}}}, {{{tactic2}}}, and {{{tactic3}}}, we can create a single tactic by writing
{{{
let combined_tactic = tactic1 THEN tactic2 THEN tactic3;;
}}}

You join the tactics together into a single tactic after you have finished the proof and want to package the proof into something that other people can use.  When you are writing down the HOL Light proof for the first time, you don't need to use {{{THEN}}} to join the tactics together.  Wait until you have finished working out the formal proof.

So for now, we ignore the {{{THEN}}} s and go through the separate tactics of the proof.

===First Line===

{{{let LL = REAL_ARITH `&1 < k ==> &0 < k`}}}

[http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/REAL_ARITH.html REAL_ARITH]

HOL Light has some powerful automated theorem proving functions built into it.  One of them is called {{{REAL_ARITH}}}.  It takes simple (backquoted) statements about the real numbers and automatically turns them into theorems.  In this proof, we will later need the simple fact that "if 1 < k then 0 < k".  Harrison starts
the IMO proof with an automated proof of this result and gives this theorem the name LL for future reference.

{{{REAL_ARITH}}} is something that you learn in Harrison's HOL Light tutorial.  


===First Tactic===

{{{REPEAT STRIP_TAC}}}

[http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/REPEAT_UPPERCASE.html REPEAT]  ----  [http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/STRIP_TAC.html STRIP_TAC]  ----  [http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/GEN_TAC.html GEN_TAC]  ----
[http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/e.html e]

The first thing we want to do in the proof is to get rid of the the "for all f and g"  (written as  {{{!f g.}}})
at the beginning of the goal.
{{{STRIP_TAC}}} or {{{GEN_TAC}}} gets rid of the "for all".   {{{GEN_TAC}}} only gets rid of the quantifier {{{!f}}}, but {{{STRIP_TAC}}} goes farther in breaking down {{{==>}}}, {{{~}}}, and {{{/\}}}.  Since we have two foralls, we want to repeat this command.  If you write {{{REPEAT}}} before a tactic, that tactic gets repeated as many times as possible.  

You can learn about the different tactics such as {{{STRIP_TAC}}}  from the following sources.

  * [http://www.cl.cam.ac.uk/~jrh13/hol-light/holchart.pdf tactics] one line summary of each tactic.
  * Type {{{help "STRIP_TAC"}}} in HOL Light to get the documentation on that tactic.
  * [http://www.cl.cam.ac.uk/~jrh13/hol-light/reference_220.html web index] gives full documentation of each tactic.  

What we actually type into the system is this:
{{{e (REPEAT STRIP_TAC);;}}}
The result is that the goal has been simplified into the following form:
{{{
val it : goalstack = 1 subgoal (1 total)

 0 [`!x y. f (x + y) + f (x - y) = &2 * f x * g y`]
 1 [`~(!x. f x = &0)`]
 2 [`!x. abs (f x) <= &1`]

`abs (g x) <= &1`
}}}
Not only did {{{STRIP_TAC}}} get rid of the quantifiers, but it moved the different assumptions into the assumption list, each on a separate line.  Many proofs start with {{{REPEAT STRIP_TAC}}} as the first tactic.  It is a convenient way to begin.

===Next Tactic===

{{{SPEC_TAC(`x:real`,`y:real`)}}}

[http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/SPEC_TAC.html SPEC_TAC]

{{{SPEC_TAC}}} works in the opposite direction as {{{GEN_TAC}}}.
The last step, which we repeated as many times as possible, took away one quantifier too many.  We put it back, renaming the variable x as y.  Look at how the tactic changes the goal:
{{{
# e (SPEC_TAC(`x:real`,`y:real`));;
val it : goalstack = 1 subgoal (1 total)

 0 [`!x y. f (x + y) + f (x - y) = &2 * f x * g y`]
 1 [`~(!x. f x = &0)`]
 2 [`!x. abs (f x) <= &1`]

`!y. abs (g y) <= &1`
}}}
===Next Tactic===

{{{ABBREV_TAC `k = sup (IMAGE (\x. abs(f(x))) (:real))`}}}

[http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/ABBREV_TAC.html ABBREV_TAC]

Until now, we have just been moving things around, without really working on the proof.   The text proof starts with the statement: "Let k be the least upper bound for |f(x)|."
This tactic implements this line of text by defining k to be an abbreviation for the sup of |f(x)|.  We need to state this more precisely than it is done in the text.   In HOL Light the function that takes {{{x}}} to {{{abs(f(x))}}} is written in lambda notation as {{{\x. abs(f(x))}}}.  (The backslash {{{\}}} is HOL Light notation for the Greek letter lambda.)  We then take the image of that function, which is a subset of the real numbers, and then the supremum of that set.   The functions {{{sup}}}, {{{IMAGE}}}, and {{{abs}}} are all part of the standard HOL Light library.   When we run this line of code, we see that it adds a new assumption, giving the definition of {{{k}}}:
{{{
# e ( ABBREV_TAC `k = sup (IMAGE (\x. abs(f(x))) (:real))` );;
val it : goalstack = 1 subgoal (1 total)

 0 [`!x y. f (x + y) + f (x - y) = &2 * f x * g y`]
 1 [`~(!x. f x = &0)`]
 2 [`!x. abs (f x) <= &1`]
 3 [`sup (IMAGE (\x. abs (f x)) (:real)) = k`]

`!y. abs (g y) <= &1`
}}}





=Exercise=

Work through Harrison's second [http://www.cs.ru.nl/~freek/demos/exercise/exercise2.pdf solution] of the IMO problem in the same way.  Look up each tactic that you do not understand in the [http://www.cl.cam.ac.uk/~jrh13/hol-light/reference_220.html master index].

After you have gone through a few formal proofs in this way,  you will be ready to formalize your own theorems.

=Further reading=

More details about this demo [http://www.cs.ru.nl/~freek/demos/ here].