#John Harrison on using HOL Light

=Video Presentation=

John Harrison gives a [http://www.math.kobe-u.ac.jp/icms2006/icms2006-video/video/v103.html video demonstration] of how to use HOL Light.  The presentation lasts about 30 minutes, followed by questions and answers.

The theorem that he proves is a problem on an old international math olympiad (IMO).

=IMO problem and solution=

The IMO problem and solution discussed by Harrison is the following.

{{{

Problem [B2 from IMO 1972]
f and g are real-valued functions defined on the real line. For all x and y,

f(x + y) + f(x - y) = 2 f(x) g(y).
f is not identically zero and |f(x)| ≤ 1 for all x. Prove that |g(x)| ≤ 1 for all x.

Solution
Let k be the least upper bound for |f(x)|. Suppose |g(y)| > 1. Then

2k ≥ |f(x + y)| + |f(x - y)| ≥ |f(x + y) + f(x - y)| = 2 |g(y)||f(x)|,
so |f(x)| ≤ k/|g(y)|. In other words, k/|g(y)| is an upper bound for |f(x)| which is less than k. Contradiction.

}}}

Here is the [http://www.cs.ru.nl/~freek/demos/exercise/exercise.pdf pdf] solution, and a second [http://www.cs.ru.nl/~freek/demos/exercise/exercise2.pdf pdf] solution.


=HOL Light solution=

The video demo shows the steps he used to create the following proof, written by Harrison.
The first part is what he did during the video demo. The second version is another proof
of the same theorem he did later.  It is not part of the demo.  After the code, I give a line-by-line
commentary on the code.

As the video and the commentary show, it is hard to read the code just by looking at it.
To understand it, you "replay" it on the computer step by step.

{{{

(* ------------------------------------------------------------------------- *)
(* Cleaned-up proof from session.                                            *)
(* ------------------------------------------------------------------------- *)

needs "Multivariate/misc.ml";;

let IMO = prove
 (`!f g. (!x y. f(x + y) + f(x - y) = &2 * f(x) * g(y)) /\
        ~(!x. f(x) = &0) /\
        (!x. abs(f(x)) <= &1)
        ==> !x. abs(g(x)) <= &1`,
 let LL = REAL_ARITH `&1 < k ==> &0 < k` in
 REPEAT STRIP_TAC THEN SPEC_TAC(`x:real`,`y:real`) THEN
 ABBREV_TAC `k = sup (IMAGE (\x. abs(f(x))) (:real))` THEN
 MP_TAC(SPEC `IMAGE (\x. abs(f(x))) (:real)` SUP) THEN
 ASM_SIMP_TAC[FORALL_IN_IMAGE; EXISTS_IN_IMAGE; IN_UNIV] THEN
 ANTS_TAC THENL [ASM SET_TAC[]; STRIP_TAC] THEN
 SIMP_TAC[GSYM REAL_NOT_LT; GSYM NOT_EXISTS_THM] THEN STRIP_TAC THEN
 FIRST_X_ASSUM(MP_TAC o SPEC `k / abs(g(y:real))`) THEN
 SIMP_TAC[NOT_IMP; NOT_FORALL_THM] THEN CONJ_TAC THENL
  [ASM_MESON_TAC[REAL_LE_RDIV_EQ; REAL_ABS_MUL; LL;
     REAL_ARITH `u + v = &2 * z /\ abs u <= k /\ abs v <= k ==> abs z <= k`];
   ASM_MESON_TAC[REAL_NOT_LE; REAL_LT_LDIV_EQ; REAL_LT_LMUL; REAL_MUL_RID; LL;
     REAL_ARITH `~(z = &0) /\ abs z <= k ==> &0 < k`]]);;

(* ------------------------------------------------------------------------- *)
(* second proof.                                                            *)
(* ------------------------------------------------------------------------- *)

let LEMMA1 = prove
 (`(!x y. f(x + y) + f(x - y) = &2 * f(x) * g(y)) /\ (!x. abs(f x) <= &1)
  ==> !l x. abs(f x * (g y) pow l) <= &1`,
 DISCH_THEN(STRIP_ASSUME_TAC o GSYM) THEN INDUCT_TAC THEN
 ASM_SIMP_TAC[real_pow; REAL_MUL_RID] THEN GEN_TAC THEN MATCH_MP_TAC
  (REAL_ARITH `abs((&2 * a * b) * c) <= &2 ==> abs(a * b * c) <= &1`) THEN
 ASM_SIMP_TAC[] THEN FIRST_ASSUM(MP_TAC o SPEC `x + y`) THEN
 FIRST_ASSUM(MP_TAC o SPEC `x - y`) THEN REAL_ARITH_TAC);;

let LEMMA2 = prove
 (`~(x = &0) /\ &1 < abs(y) ==> ?n. &1 < abs(y pow n * x)`,
 SIMP_TAC[REAL_ABS_MUL; REAL_ABS_POW; GSYM REAL_LT_LDIV_EQ;
          GSYM REAL_ABS_NZ; REAL_ARCH_POW]);;

let IMO = prove
 (`!f g. (!x y. f(x + y) + f(x - y) = &2 * f(x) * g(y)) /\
        ~(!x. f(x) = &0) /\
        (!x. abs(f(x)) <= &1)
        ==> !x. abs(g(x)) <= &1`,
 MESON_TAC[LEMMA1; LEMMA2; REAL_NOT_LE; REAL_MUL_SYM]);;


}}}

=Commentary=

To get started, install [http://caml.inria.fr/ CAML] and [http://www.cl.cam.ac.uk/~jrh13/hol-light/ HOL Light] on your machine, following the instructions on page 5 of the [http://www.cl.cam.ac.uk/~jrh13/hol-light/tutorial_220.pdf tutorial].  It runs on most computers.

Start a session of CAML.  Load HOL Light.

==Step 0. Understand the conventional Proof==

Every formal proof starts with a conventional proof (that is, non-formal proof).  We should study the conventional math proof of the IMO problem (given above) and understand it thoroughly.  With a thorough understanding of the conventional proof, we are ready to move on.

==Step 1. Load theorems==
The first step of  the proof is
{{{
needs "Multivariate/misc.ml";;
}}}
In his proof of the IMO problem, Harrison uses some theorems that have already been proved in the file {{{"Multivariate/misc.ml"}}}.  This line tells the theorem prover to load those theorems.

==Step 2. State the theorem to be proved.==
The statement of the problem
{{{
f and g are real-valued functions defined on the real line. For all x and y,

f(x + y) + f(x - y) = 2 f(x) g(y).
f is not identically zero and |f(x)| ≤ 1 for all x. Prove that |g(x)| ≤ 1 for all x.
}}}
appears in HOL Light as follows:
{{{
let IMO = prove
 (`!f g. (!x y. f(x + y) + f(x - y) = &2 * f(x) * g(y)) /\
        ~(!x. f(x) = &0) /\
        (!x. abs(f(x)) <= &1)
        ==> !x. abs(g(x)) <= &1`,  (* TACTIC HERE *)  );;
}}}
The notation is explained in the HOL Light tutorial.  Real numbers need to be marked with {{{&}}}.  For instance,
{{{&0}}} is the real number zero (as opposed to the natural number zero {{{0}}}).  The logical symbol "and" is
typed as {{{/\}}}, "less than or equal" appears as {{{<=}}}, "the absolute value" as {{{abs}}}.  It is necessary to learn the names of different functions from the tutorial.

The function {{{prove}}} takes two arguments, a backquoted string giving the result that is to be proved, and a tactic that gives the proof.  The {{{prove}}} function is used after the proof is complete to package the proof into something that can be used by other people.  When the proof is being worked out, the desired theorem is stated as a goal.  For this, type {{{g}}} for goal and then the backquoted string.

{{{
g `!f g. (!x y. f(x + y) + f(x - y) = &2 * f(x) * g(y)) /\
        ~(!x. f(x) = &0) /\
        (!x. abs(f(x)) <= &1)
        ==> !x. abs(g(x)) <= &1`;;
}}}

==Step 3.  Work out proof tactics==

The style of proving in HOL Light is generally "backwards".  This means that you start out with a goal of what you want to prove (in this case the IMO problem), and work backwards until you have reduced the goal to easier statements that are easy to prove.  Each backwards step of the proof is called a tactic.  If you look at the HOL Light proof of the IMO problem,  it has the general form
{{{
let IMO = prove
 (   (* backquoted goal *) ,  (* tactic *)  );;
}}}
The tactic, if you look carefully, is a long sequence of separate commands joined together with {{{THEN}}}.
The {{{THEN}}} function makes a single tactic out of many tactics.  For example, if we have three backwards proof steps called {{{tactic1}}}, {{{tactic2}}}, and {{{tactic3}}}, we can create a single tactic by writing
{{{
let combined_tactic = tactic1 THEN tactic2 THEN tactic3;;
}}}

You join the tactics together into a single tactic after you have finished the proof and want to package the proof into something that other people can use.  When you are writing down the HOL Light proof for the first time, you don't need to use {{{THEN}}} to join the tactics together.  Wait until you have finished working out the formal proof.

So for now, we ignore the {{{THEN}}} s and go through the separate tactics of the proof.

===First Line===

{{{let LL = REAL_ARITH `&1 < k ==> &0 < k`}}}

HOL Light has some powerful automated theorem proving functions built into it.  One of them is called {{{REAL_ARITH}}}.  It takes simple (backquoted) statements about the real numbers and automatically turns them into theorems.  In this proof, we will later need the simple fact that "if 1 < k then 0 < k".  Harrison starts
the IMO proof with an automated proof of this result and gives this theorem the name LL for future reference.

{{{REAL_ARITH}}} is something that you learn in Harrison's HOL Light tutorial.  


===Second Line===

{{{REPEAT STRIP_TAC}}}

The first thing we want to do in the proof is to get rid of the the "for all f and g"  (written as  {{{!f g.}}})
at the beginning of the goal.
{{{STRIP_TAC}}} or {{{GEN_TAC}}} gets rid of the "for all".   {{{GEN_TAC}}} only gets rid of the quantifier {{{!f}}}, but {{{STRIP_TAC}}} goes farther in breaking down {{{==>}}}, {{{~}}}, and {{{/\}}}.  Since we have two foralls, we want to repeat this command.  If you write {{{REPEAT}}} before a tactic, that tactic gets repeated as many times as possible.  


You can learn about the different tactics such as {{{STRIP_TAC}}}  from the following sources.

  * [http://www.cl.cam.ac.uk/~jrh13/hol-light/holchart.pdf tactics] one line summary of each tactic.
  * Type {{{help "STRIP_TAC"}}} in HOL Light to get the documentation on that tactic.
  * [http://www.cl.cam.ac.uk/~jrh13/hol-light/reference_220.html web index] gives full documentation of each tactic.  Here is the documentation on [http://www.cl.cam.ac.uk/~jrh13/hol-light/HTML/STRIP_TAC.html STRIP_TAC].

What we actually type into the system is this:
{{{e (REPEAT STRIP_TAC);;}}}
The result is that the goal has been simplified into the following form:
{{{
val it : goalstack = 1 subgoal (1 total)

 0 [`!x y. f (x + y) + f (x - y) = &2 * f x * g y`]
 1 [`~(!x. f x = &0)`]
 2 [`!x. abs (f x) <= &1`]

`abs (g x) <= &1`
}}}
Not only did {{{STRIP_TAC}}} get rid of the quantifiers, but it moved the different assumptions into the assumption list, each on a separate line.  Many proofs start with {{{REPEAT STRIP_TAC}}} as the first tactic.  It is a convenient way to begin.


=Further reading=

More details about this demo [http://www.cs.ru.nl/~freek/demos/ here].